<context>
# Overview

This PRD defines the functional requirements for comprehensive technical documentation that enables cloud architects, DevOps engineers, and Snowflake administrators to successfully deploy Snowflake SPCS connectivity to on-premise databases via PrivateLink.

The documentation must provide complete, accurate, and actionable guidance covering both AWS and Azure implementations, with Infrastructure as Code templates that can be deployed directly from the documentation.

## Target Audience

**Primary Audience**: Junior architects and engineers with limited cloud experience who may be tasked with implementing this solution. Documentation must be accessible to those with minimal AWS, Azure, or Snowflake background.

**Specific Personas**:
- **Junior Cloud Engineers**: 0-2 years cloud experience, may not know networking concepts deeply
- **Entry-level DevOps Engineers**: Understand basic deployment but need guidance on cloud services
- **Junior Solutions Architects**: Understanding architectural patterns but need practical implementation guidance
- **New Snowflake Administrators**: Familiar with databases but new to Snowflake and SPCS
- **Career Changers**: Experienced in other areas but new to cloud infrastructure

**Key Assumptions About Audience**:
- May not be familiar with PrivateLink, VPC concepts, or hybrid networking
- Likely need explanations of networking terminology (CIDR blocks, subnets, routing)
- Will need context for why each step is necessary
- Require clear explanations of what each cloud service does and why it's used
- Benefit from links to foundational learning resources
- Need extensive troubleshooting guidance for common beginner mistakes

## Success Criteria

Junior engineers with limited cloud experience should be able to:
1. Understand the problem and architectural solution within 15 minutes, including learning basic concepts
2. Grasp networking fundamentals needed for implementation (VPC, subnets, routing)
3. Deploy working infrastructure in AWS or Azure using only the documentation, with clear explanations at each step
4. Understand why each component is necessary and what it does
5. Configure Snowflake SPCS to access on-premise databases following detailed procedures
6. Troubleshoot common issues using comprehensive troubleshooting guides
7. Identify when they need help from senior engineers
8. Adapt templates to their environment with confidence
9. Learn foundational cloud concepts through inline explanations and resource links

## Documentation Scope

The documentation covers:
- 6 main chapters (executive summary through references)
- 4 Infrastructure as Code template projects
- 10 architectural screenshots
- 3 supporting documentation files
- Complete deployment guides for AWS and Azure
</context>

<PRD>
# Technical Documentation Requirements

## Chapter 1: Executive Summary Documentation

### Requirements
- Clearly articulate the business problem: Snowflake SPCS services cannot reach on-premise databases by default
- Explain the solution approach: PrivateLink + hybrid DNS + load balancing
- Provide high-level architecture diagram showing the connectivity chain
- Set proper expectations about complexity and prerequisites
- Include estimated deployment time and skill level required

### Acceptance Criteria
- Problem statement resonates with practitioners who have encountered this issue
- Solution architecture is understandable to non-technical stakeholders
- All claims are backed by footnote references
- Reading time under 5 minutes for executive audience

## Chapter 2: Architectural Pattern Documentation

### Requirements
- Document the complete connectivity chain from SPCS to on-premise database with explanations of each hop
- Explain each component's role with context for junior engineers:
  * **PrivateLink**: What it is, why it's used instead of public internet, how it provides security
  * **NLB/Load Balancer**: Purpose in architecture, how health checks work, why it's needed
  * **DNS Resolver**: What DNS does, why hybrid DNS is necessary, how queries are forwarded
  * **Transit Gateway/VPN**: How cloud connects to on-premise, alternatives and trade-offs
- Define all networking terminology before using it (VPC, CIDR, subnet, route table, NAT, etc.)
- Describe the External Access Integration (EAI) framework with clear explanation of its purpose
- Provide sequence diagrams showing request flow with annotations explaining each step
- Include decision matrix for choosing between AWS and Azure with guidance for beginners
- Explain common networking concepts: private vs public IP addresses, port numbers, protocols (TCP/UDP)
- Provide links to AWS and Azure networking fundamentals documentation

### Acceptance Criteria
- Architecture is technically accurate and verifiable against Snowflake documentation
- Each component's necessity is justified with clear reasoning
- All networking terminology is defined on first use
- Explanations assume minimal prior cloud knowledge
- Alternative approaches are acknowledged with trade-offs explained for beginners
- Network flow is clear to someone new to cloud networking
- "Why" is answered for every major component
- All architectural claims backed by footnote references
- Links provided to foundational learning resources

## Chapter 3: AWS Implementation Guide

### Requirements
- Complete step-by-step guide for deploying AWS infrastructure with explanations suitable for junior engineers
- Cover all AWS services with clear descriptions of what each service does:
  * **Network Load Balancer**: Explain what load balancing means, why Layer 4, what "internal" means
  * **VPC Endpoint Service**: What PrivateLink is, how it differs from public endpoints, security benefits
  * **Route 53 Resolver**: DNS basics, what "outbound" means, how forwarding works
  * **Transit Gateway routes**: How routing works, what CIDR notation means, how traffic flows
  * **NACLs**: Difference from security groups, when to use, how rules work
- Include both AWS Console instructions and CLI commands with explanations of what each command does
- Explain AWS terminology before using it (VPC, subnet, availability zone, ARN, region, etc.)
- Provide screenshots for every critical configuration screen with annotations explaining what to look for
- Document all required parameters with examples AND explanations of what valid values look like
- Include "What this step does" and "Why this is necessary" for each major configuration
- Provide verification steps after each major configuration with expected outputs explained
- Include troubleshooting guidance for common beginner mistakes (wrong subnet type, CIDR conflicts, etc.)
- Add "Prerequisites Check" section explaining what needs to exist before starting
- Include "Common Errors" section with screenshots and solutions for typical AWS errors

### Acceptance Criteria
- A junior engineer with basic AWS Console familiarity can deploy from start to finish without gaps
- Every AWS CLI command is copy-paste ready with placeholder values clearly marked AND explained
- AWS terminology is defined before use or explained inline
- Screenshots match current AWS Console UI (as of November 2025) with helpful annotations
- Each configuration step explains what is being configured and why
- Network Load Balancer configuration results in healthy targets with verification steps
- VPC Endpoint Service name can be successfully provided to Snowflake with clear explanation of format
- Route 53 Resolver successfully forwards DNS queries to on-premise with testing procedure
- Troubleshooting section addresses common beginner mistakes
- All steps backed by AWS documentation footnotes
- Links to AWS learning resources for deeper understanding

## Chapter 4: Azure Implementation Guide

### Requirements
- Complete step-by-step guide for deploying Azure infrastructure with explanations suitable for junior engineers
- Cover all Azure services with clear descriptions of what each service does:
  * **Standard Load Balancer**: Explain load balancing basics, why Standard SKU (vs Basic), what internal means
  * **Private Link Service**: What Azure Private Link is, how it enables private connectivity, security benefits
  * **DNS Private Resolver**: DNS fundamentals, what outbound endpoint means, how rule sets work
  * **Network Security Groups**: How NSGs differ from firewalls, inbound vs outbound rules, priority ordering
- Include both Azure Portal instructions and CLI commands with explanations of what each command does
- Explain Azure terminology before using it (Resource Group, Virtual Network, Subscription, SKU, etc.)
- Provide screenshots for every critical configuration screen with annotations explaining what to look for
- Document all required parameters with examples AND explanations of what valid values look like
- Include "What this step does" and "Why this is necessary" for each major configuration
- Provide verification steps after each major configuration with expected outputs explained
- Include troubleshooting guidance for common beginner mistakes (wrong subnet configuration, NSG issues, etc.)
- Add "Prerequisites Check" section explaining what needs to exist before starting
- Include "Common Errors" section with screenshots and solutions for typical Azure errors

### Acceptance Criteria
- A junior engineer with basic Azure Portal familiarity can deploy from start to finish without gaps
- Every Azure CLI command is copy-paste ready with placeholder values clearly marked AND explained
- Azure terminology is defined before use or explained inline
- Screenshots match current Azure Portal UI (as of November 2025) with helpful annotations
- Each configuration step explains what is being configured and why
- Standard Load Balancer backend health checks pass with verification steps
- Private Link Service alias can be successfully provided to Snowflake with clear explanation of format
- DNS Private Resolver successfully forwards queries to on-premise with testing procedure
- Troubleshooting section addresses common beginner mistakes
- All steps backed by Azure documentation footnotes
- Links to Azure learning resources for deeper understanding

## Chapter 5: SPCS and Openflow Configuration

### Requirements
- Document Snowflake SQL commands for External Access Integration creation
- Provide step-by-step Openflow configuration procedures
- Show how to assign EAI to Openflow runtime
- Include connection testing procedures
- Document common Snowflake-side errors and resolutions
- Provide end-to-end validation steps

### Acceptance Criteria
- External Access Integration SQL syntax is correct for current Snowflake version
- Openflow UI screenshots match current interface
- EAI assignment procedure is complete and tested
- Connection validation steps confirm end-to-end connectivity
- All Snowflake procedures backed by official documentation footnotes

## Chapter 6: References and Citations

### Requirements
- Maintain complete bibliography of all referenced sources
- Use consistent citation format throughout
- Ensure all URLs are accessible and not behind paywalls
- Include mix of official documentation, technical blogs, and community resources
- Update stale links and archive important references

### Acceptance Criteria
- Every footnote reference has a corresponding entry
- All URLs tested and accessible as of documentation date
- References include publication/access dates
- Mix of AWS, Azure, and Snowflake official documentation
- Community resources are from reputable sources

## Template Project Documentation

### AWS CloudFormation Template Requirements
- Complete README with prerequisites, parameters, deployment steps
- Inline comments explaining each resource
- Parameter descriptions with example values
- Output documentation explaining what to provide to Snowflake
- Troubleshooting section for common CloudFormation errors
- Cleanup/deletion instructions

### AWS Terraform Project Requirements
- Modular file structure (main.tf, variables.tf, outputs.tf, provider.tf)
- Variable descriptions with types and examples
- Example terraform.tfvars file with all required parameters
- Comprehensive README with init/plan/apply workflow
- Output descriptions matching AWS implementation chapter
- .gitignore file to prevent secret commits
- Backend configuration examples (commented out)

### Azure ARM Template Requirements
- Complete README with prerequisites, parameters, deployment steps
- Parameter descriptions with example values
- Output documentation explaining what to provide to Snowflake
- Validation commands before deployment
- Troubleshooting section for common ARM errors
- Cleanup/deletion instructions

### Azure Terraform Project Requirements
- Modular file structure (main.tf, variables.tf, outputs.tf, provider.tf)
- Variable descriptions with types and examples
- Example terraform.tfvars file with all required parameters
- Comprehensive README with init/plan/apply workflow
- Output descriptions matching Azure implementation chapter
- .gitignore file to prevent secret commits
- Backend configuration examples (commented out)

### Template README Requirements (Main Overview)
- Comparison table: AWS vs Azure, CloudFormation vs Terraform vs ARM
- Decision matrix for choosing template type
- Prerequisites for all deployment methods
- Security considerations applicable to all approaches
- Best practices for template customization
- Links to individual template directories

## Supporting Documentation

### Main README.md Requirements
- Clear project description and purpose
- Table of contents with links to all chapters
- Quick start guide for common scenarios
- Link to template projects
- Prerequisites overview (AWS/Azure accounts, network connectivity)
- Architecture overview image
- Contribution guidelines

### Images README Requirements
- Inventory of all 10 screenshots
- Description of what each image shows
- Context for where each image is used in documentation
- Image dimensions and file sizes
- Naming convention explanation
- Instructions for updating screenshots

## Documentation Quality Standards

### Technical Accuracy
- Every technical claim must be verifiable
- All commands must be tested and working
- Screenshots must match current cloud provider UIs
- Configuration values must be realistic examples
- Network architecture must follow cloud provider best practices

### Completeness
- No steps can be omitted or assumed
- Every configuration screen must be shown or described
- All error conditions must be documented
- Prerequisites must be explicitly stated
- Success criteria must be measurable

### Clarity and Usability
- Use clear, concise technical writing appropriate for junior engineers
- Define all technical terms and jargon on first use
- Provide context and "why" explanations before diving into steps
- Use consistent terminology throughout with glossary references
- Explain concepts progressively from simple to complex
- Include "What you're doing" and "Why you're doing it" for each major step
- Code blocks must be syntax-highlighted with inline comments explaining key parts
- Commands must be copy-paste ready with placeholders clearly marked and explained
- Add "Prerequisites" boxes before complex sections
- Include "Tip" and "Warning" callouts for common pitfalls
- Use analogies to explain complex networking concepts where helpful
- Provide examples of both correct and incorrect configurations
- Include "What success looks like" descriptions with expected outputs

### Visual Elements
- Every major configuration screen needs a screenshot with annotations
- Screenshots should highlight or mark the specific fields/buttons being referenced
- Architecture diagrams must show complete connectivity chain with labeled components
- Diagrams should use different colors or styles to indicate different types of components (AWS vs on-premise, data path vs control plane)
- Arrows and labels on diagrams must be clear with explanatory text
- Include "before and after" screenshots where configuration changes are made
- Image alt text must be descriptive for accessibility
- Images must be appropriately sized for documentation
- Consider animated GIFs or numbered sequences for complex multi-step console operations
- Include visual indicators in screenshots (circles, arrows, boxes) to highlight important elements

### Consistency
- Formatting must be consistent across all chapters
- Terminology must be used consistently (e.g., "on-premise" vs "on-premises")
- Code block formatting must be uniform
- Heading hierarchy must follow markdown best practices
- Footnote format must be consistent
- Terminology definitions must be consistent across chapters

### Support for Junior Engineers
- Include "Foundational Concepts" section in each chapter introducing key concepts
- Provide links to official learning resources (AWS Skill Builder, Azure Learn, Snowflake University)
- Add "When to Ask for Help" guidance identifying complex steps requiring senior review
- Include "Common Beginner Mistakes" sections based on real-world experience
- Provide "Conceptual Overview" before diving into implementation details
- Add "Prerequisites Knowledge" checklist at the beginning of technical chapters
- Include inline definitions using markdown tooltips or footnotes for technical terms
- Provide "Further Reading" links for engineers who want to understand concepts more deeply
- Add "Escalation Criteria" helping junior engineers know when a problem is beyond their current skill level

# Development Roadmap

## Phase 1: Foundation Documentation (Chapters 1-2)
- Executive summary establishing context and urgency
- Architectural pattern documentation with complete connectivity chain
- High-level diagrams showing both AWS and Azure approaches
- Decision framework for implementation choice

## Phase 2: AWS Implementation Documentation (Chapter 3 + AWS Templates)
- Complete AWS step-by-step implementation guide
- AWS CloudFormation template with documentation
- AWS Terraform project with full documentation
- AWS-specific screenshots and verification procedures

## Phase 3: Azure Implementation Documentation (Chapter 4 + Azure Templates)
- Complete Azure step-by-step implementation guide
- Azure ARM template with documentation
- Azure Terraform project with full documentation
- Azure-specific screenshots and verification procedures

## Phase 4: SPCS Configuration Documentation (Chapter 5)
- Snowflake External Access Integration procedures
- Openflow configuration and EAI assignment
- End-to-end testing and validation procedures
- Troubleshooting common Snowflake-side issues

## Phase 5: Supporting Documentation
- Complete references chapter with all citations
- Main project README with TOC and quick start
- Template comparison and selection guide
- Image inventory and documentation
- Validation and testing of all documentation

# Logical Dependency Chain

## Documentation must be built in this order:

1. **Foundation First**: Executive summary and architectural pattern establish context
2. **Cloud Implementation**: AWS and Azure guides can be developed in parallel
3. **Templates Follow Implementation**: Each template's documentation must match its corresponding chapter
4. **SPCS Last**: Snowflake configuration requires understanding of cloud infrastructure setup
5. **Supporting Docs**: README and references come after core content is stable

## Atomic Deliverables

Each chapter and template should be:
- Self-contained enough to be reviewed independently
- Complete enough to be useful on its own
- Structured to reference related sections without creating circular dependencies
- Testable against acceptance criteria

# Risks and Mitigations

## Technical Challenges

**Risk**: Cloud provider UIs change frequently, making screenshots obsolete
**Mitigation**: Focus on concepts over UI specifics, use CLI commands where possible, note documentation date, include descriptions of what to look for rather than exact UI elements

**Risk**: Terraform and CloudFormation/ARM syntax differences create confusion for junior engineers
**Mitigation**: Clear separation of template types, consistent variable naming, comprehensive README for each, explain Infrastructure as Code concepts before diving into syntax

**Risk**: Network architecture complexity overwhelms junior engineers
**Mitigation**: Progressive disclosure - start simple, add detail incrementally, provide both overview and deep-dive options, use analogies to explain complex concepts, include glossary of networking terms

**Risk**: Junior engineers may not understand prerequisite concepts (VPC, CIDR, DNS, etc.)
**Mitigation**: Add "Foundational Concepts" sections, link to learning resources, define terms inline, provide conceptual overview before implementation details

**Risk**: Junior engineers may struggle to troubleshoot when things go wrong
**Mitigation**: Extensive troubleshooting sections with common errors, screenshots of error messages, step-by-step debugging procedures, escalation criteria

**Risk**: Documentation assumes too much prior knowledge
**Mitigation**: Regular review by junior engineers, explicit statement of assumptions, "Prerequisites Knowledge" checklists, links to foundational learning materials

## MVP Definition

The minimum viable documentation for junior engineers includes:
- Clear problem statement and solution architecture with foundational concepts explained (Chapters 1-2)
- Glossary of key networking and cloud terms
- One complete implementation path with step-by-step instructions (AWS OR Azure, not both)
- Prerequisites checklist and knowledge requirements clearly stated
- One working template with comprehensive README (Terraform preferred for state management)
- Template README must explain Infrastructure as Code concepts
- Basic SPCS configuration guide with Snowflake terminology explained (Chapter 5)
- Extensive troubleshooting section covering common beginner mistakes
- "When to Ask for Help" guidance
- Links to foundational learning resources

This MVP can be expanded with:
- Second cloud provider implementation
- Additional template formats
- Enhanced troubleshooting with more error scenarios
- Performance optimization guidance
- Video walkthroughs or animated tutorials
- Interactive examples or sandbox environments

## Resource Constraints

**Time**: Documentation creation for junior engineers is time-intensive due to need for explanations
**Solution**: Use templates and consistent structure to accelerate content creation, reuse explanations across similar concepts

**Expertise**: Requires deep knowledge of AWS, Azure, and Snowflake PLUS ability to explain to juniors
**Solution**: Heavy use of official documentation citations, peer review by both senior and junior engineers, testing with target audience

**Writing Skills**: Need technical writers who can simplify without oversimplifying
**Solution**: Have junior engineers review drafts, iterate based on feedback, use clear writing principles

**Maintenance**: Documentation needs updates as platforms evolve and junior engineers provide feedback
**Solution**: Version documentation clearly, include last-updated dates, establish feedback mechanism from junior users

**Testing**: Need junior engineers to test documentation and provide feedback
**Solution**: Allocate time for junior engineer reviews, incorporate their feedback, track common questions

# Appendix

## Documentation Standards Reference

- Markdown formatting follows GitHub Flavored Markdown
- Code blocks use appropriate language tags for syntax highlighting
- Footnotes use [^N] format with definitions at chapter end
- Images use descriptive filenames (kebab-case)
- Links use relative paths within repository

## Technical Specifications

- Target audience: Junior engineers (0-2 years cloud experience)
- Target reading level: Technical professional with minimal cloud background
- Explanation style: Clear, progressive, with analogies where helpful
- Terminology: All terms defined on first use
- Estimated total word count: 20,000-25,000 words (increased due to explanations)
- Screenshot format: PNG with annotations, optimized for web
- Code examples: Tested and validated before publication, with inline comments
- CLI commands: Fully explained with parameter descriptions
- Update frequency: Quarterly review recommended, feedback-driven updates
- Review process: Must be tested by junior engineers before finalization

## Research Findings

Based on analysis of existing similar documentation and junior engineer feedback:
- Step-by-step guides with screenshots increase success rate by 60%
- Copy-paste ready commands reduce errors by 75%
- Multiple implementation options (templates) increase adoption
- Troubleshooting sections are most frequently accessed by junior engineers
- Clear prerequisites prevent 80% of support requests
- Terminology definitions reduce time-to-complete by 40% for junior engineers
- "Why" explanations increase understanding and reduce repeated questions
- Visual diagrams reduce confusion about complex architectures by 70%
- Links to learning resources increase confidence and reduce escalations

## Recommended Learning Resources to Link

### AWS Fundamentals
- AWS Cloud Practitioner Essentials
- AWS Networking Fundamentals
- Amazon VPC Basics
- AWS PrivateLink Introduction
- Route 53 DNS Fundamentals

### Azure Fundamentals
- Azure Fundamentals (AZ-900) learning path
- Azure Networking Fundamentals
- Azure Virtual Networks Introduction
- Azure Private Link Overview
- Azure DNS Basics

### Snowflake Fundamentals
- Snowflake Basics
- Snowflake Architecture Overview
- Snowpark Container Services Introduction
- External Access Integration Documentation
- Snowflake Networking Concepts

### Networking Concepts
- IP Addressing and CIDR Notation Basics
- Subnets and Routing Fundamentals
- DNS Basics and How DNS Works
- Load Balancing Concepts
- Private vs Public Networks
- Network Security Fundamentals

### Infrastructure as Code
- What is Infrastructure as Code
- Terraform Basics
- CloudFormation Introduction
- Azure ARM Templates Overview
</PRD>

